<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Selection Tool</title>
    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet" media="screen" />
    <link
      href="../css/bootstrap-theme.min.css"
      rel="stylesheet"
      media="screen"
    />
    <link
      href="../css/nchrp1441.css?v=20160525"
      rel="stylesheet"
      media="screen,print"
    />
    <link
      href="../css/nchrp1441-facility.css?v=20160525"
      rel="stylesheet"
      media="screen,print"
    />
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Open+Sans"
      rel="stylesheet"
      type="text/css"
      media="print"
    />
    <link
      href="https://cdn.datatables.net/1.11.5/css/dataTables.bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <!-- bootstrap multiselect -->
    <link rel="stylesheet" href="./css/bootstrap-select.min.css" />
    <script src="./js/bootstrap-select.min.js"></script>

    <!-- lightbox 2 -->
    <link href="./css/lightbox.min.css" rel="stylesheet" />
    <script src="./js/lightbox.min.js"></script>

    <style>
      @font-face {
        font-family: "Glyphicons Halflings";
        src: url("./fonts/glyphicons-halflings-regular.eot"); /* your path */
        src: url("./fonts/glyphicons-halflings-regular.eot?#iefix")
            format("embedded-opentype"),
          url("./fonts/glyphicons-halflings-regular.woff2") format("woff2"),
          url("./fonts/glyphicons-halflings-regular.woff") format("woff"),
          url("./fonts/glyphicons-halflings-regular.ttf") format("truetype"),
          url("./fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular")
            format("svg");
        /* keep the same family name so Bootstrap's .glyphicon rules still work */
      }
    </style>

    <style>
      /* Style for selected card */
      .selected-card {
        background-color: #d1e7dd !important; /* Light green for selected */
      }
      /* Style for fixed bottom-right button container */
      .fixed-buttons {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: none;
        z-index: 1000;
      }
      .fixed-buttons-left {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 1000;
      }
      /* Card layout */
      .card-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
      }
      .card-text-content {
        width: 70%;
      }
      .card-img-content {
        width: 25%;
      }
      .select-item {
        display: inline-block;
        margin-right: 10px;
      }
    </style>
    <style>
      a:hover {
        text-decoration: none !important;
      }
      .list-group-item:first-child {
        background-color: #ccc;
      }
      .indent-level-1 {
        padding-left: 20px;
        background-color: #eee;
      }
      .indent-level-2 {
        padding-left: 40px;
      }
      .removable-filter {
        margin-right: 5px;
        cursor: pointer;
      }
      .removable-filter i {
        margin-left: 5px;
      }
      #clearFilters {
        margin-top: 10px;
      }
      .icon-indicator {
        font-size: 30px;
        line-height: 24px;
      }
      .group-title {
        font-size: 22px;
      }
      .accordion-toggle:focus,
      .panel-title > a:focus {
        text-decoration: none;
        outline: none;
      }
      .nav-tabs {
        border-bottom: none;
      }
      .tab_item:hover {
        border-bottom-width: 6px !important;
      }
      .tab-content {
        padding-top: 10px;
      }
      .img-item {
        padding: 5px;
      }
      .panel-level-2-heading {
        background-color: #f7f7f7;
        border-top: 3px solid #4d6832;
      }
      .panel-level-2-heading:hover {
        background-color: #4d683263;
      }
      .list-group-item.active,
      list-group-item:hover {
        background-color: #4d6832 !important;
        background-image: none;
        border: none;
      }
      .bg-blue,
      .bg-blue:hover {
        background-color: #4d6832 !important;
        color: white;
      }
      .label-custom {
        font-size: 13px;
      }
      label {
        color: black !important;
      }
      .card-text-content p,
      .card-bottom-content p {
        margin-bottom: 0;
      }
      /* Custom CSS for DataTables sorting arrows with Font Awesome 4.4 */
      table.dataTable thead .sorting:after {
        content: "\25B2\25BC"; /* Add both up and down arrow symbols */
        font-family: Arial, sans-serif; /* Use standard font for arrows */
        opacity: 0.3;
        margin-left: 5px;
      }

      table.dataTable thead .sorting_asc:after {
        content: "\25B2"; /* Up arrow for ascending */
        opacity: 1;
      }

      table.dataTable thead .sorting_desc:after {
        content: "\25BC"; /* Down arrow for descending */
        opacity: 1;
      }

      .panel-mt {
        margin-top: 30px;
        border-top: 5px solid green;
      }
      /* CSS for text overflow with ellipsis */
      .text-overflow {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 120px;
        vertical-align: middle;
      }
      .pagination > .active > a {
        background-color: #4d6832 !important;
        border-color: #4d6832 !important;
        color: white !important;
      }
      .pagination > li > a,
      .pagination > li > span {
        color: #4d6832 !important;
      }
    </style>
    <style>
      /* Fixed sidebar */
      .fixed-sidebar {
        height: calc(100vh - 60px);
        overflow-y: auto;
        background-color: #dff0d8; /* Light green background */
      }

      /* Scrollable main content */
      .scrollable-content {
        overflow-y: auto;
        height: 100vh;
        padding-top: 20px;
      }

      /* Button positioned at the bottom of the sidebar */
      .bottom-button-container {
        position: absolute;
        bottom: 20px;
        text-align: center;
        left: 50%;
        transform: translateX(-50%);
      }

      .bottom-button {
        background-color: #4d9fd9;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        font-size: 16px;
        cursor: pointer;
        width: 100%;
      }
    </style>
    <style>
      /* The container holds the off-canvas positioning context */
      #app {
        position: relative;
      }

      /* Sidebar base (as a normal column on md+) */
      .sidebar {
        background: #f8f8f8;
        border-right: 1px solid #ddd;
        padding-left: 0;
        padding-right: 0;
      }

      /* Sidebar nav look */
      .sidebar .nav > li > a {
        padding: 10px 15px;
      }

      /* md+ (≥992px): just a normal grid layout */
      @media (min-width: 992px) {
        .sidebar-overlay {
          display: none !important;
        }
      }

      /* xs/sm (≤991px): sidebar becomes off-canvas INSIDE the container */
      @media (max-width: 991px) {
        /* Take the sidebar out of the flow and slide it in */
        .sidebar {
          position: absolute;
          top: 0;
          left: 0;
          width: 240px;
          z-index: 1030;
          overflow-y: auto;
          box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
          background: #f8f8f8;

          /* Off-canvas via transforms */
          -webkit-transform: translateX(-110%);
          transform: translateX(-110%);
          -webkit-transition: -webkit-transform 0.25s ease-in-out;
          transition: transform 0.25s ease-in-out;
        }
        .sidebar.open {
          -webkit-transform: translateX(0);
          transform: translateX(0);
        }

        /* Content spans full width on mobile */
        .content {
          float: none;
          width: 100%;
        }

        /* Overlay only within the container bounds */
        .sidebar-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.25);
          z-index: 1029;
          display: none;
          height: 100vh;
        }
        .sidebar-overlay.show {
          display: block;
        }
      }
    </style>
    <style>
      /* Gray out disabled checkboxes and their labels */
      label.disabled {
        cursor: not-allowed;
        color: #aaa !important;
      }
      /* container + spacing */
      .fav-simple {
        display: inline-flex;
        align-items: center;
        padding: 4px 8px; /* ← padding you asked for */
        margin: 0;
        cursor: pointer;
        font-size: 1.5rem;
        border: 1px solid gray;
        border-radius: 5px;
        padding: 5px 10px;
        margin-left: 15px;
      }

      /* small gap before the text */
      .fav-simple .fav-item {
        margin-right: 6px;
      }

      /* colors: unchecked = gray, checked = green */
      .fav-simple .fav-text {
        color: #777; /* not favorite */
      }

      .fav-simple .fav-item:checked ~ .fav-text {
        color: #00589C; /* favorite (Bootstrap success green) */
        font-weight: 600;
      }
    </style>
  </head>
  <body class="facility">
    <header
      class="navbar navbar-static-top navbar-inverse"
      id="top"
      role="banner"
    >
      <div class="container v2">
        <div class="navbar-header">
          <!-- NEW: Sidebar toggle for xs/sm -->
          <button
            type="button"
            class="navbar-toggle sidebar-toggle visible-xs visible-sm"
            aria-label="Toggle sidebar"
            aria-controls="sidebar"
            aria-expanded="false"
          >
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>

          <button
            class="navbar-toggle collapsed"
            type="button"
            data-toggle="collapse"
            data-target=".bs-navbar-collapse"
          >
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>

          <a href="../index.htm" class="navbar-brand">NCHRP 17-113</a>
        </div>

        <nav class="collapse navbar-collapse bs-navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.htm">Home</a></li>
            <li><a href="../about.htm">About</a></li>
            <li class="active"><a href="tool2.html">Selection Tool</a></li>
            <li><a href="resource.htm">Resource Library</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <!-- Main page container with sidebar INSIDE -->
    <main id="app" class="container">
      <div class="row app-row">
        <!-- Sidebar column (normal col on md+, off-canvas on xs/sm) -->
        <aside
          id="sidebar"
          class="sidebar col-md-3 alert alert-success"
          style="background-color: #dff0d8; padding: 10px 15px"
        >
          <h2>Filters</h2>
          <p style="margin-bottom: 1rem; color: black">
            Please select inputs to filter countermeasures.
          </p>

          <form id="filterForm">
            <!-- Emphasis Area -->
            <div class="form-group">
              <label for="focusArea">Emphasis Area</label>
              <select
                id="focusArea"
                class="form-control custom-select-picker"
                multiple
              ></select>
            </div>

            <!-- Target Crash -->
            <div class="form-group">
              <label for="targetCrash">Target Crash Type</label>
              <select
                id="targetCrash"
                class="form-control custom-select-picker"
                multiple
              >
                <!-- <option value="">Select Target Crash</option> -->
              </select>
            </div>

            <!-- Contributing Factors -->
            <div class="form-group">
              <label for="contributingFactors">Contributing Factors</label>
              <select
                id="contributingFactors"
                class="form-control custom-select-picker"
                multiple
              >
                <!-- <option value="">Select Contributing Factors</option> -->
              </select>
            </div>

            <!-- Area Type -->
            <div class="form-group">
              <label for="areaType">Land Use Type</label>
              <select
                id="areaType"
                class="form-control custom-select-picker"
                multiple
              >
                <!-- <option value="">Select Land Use Type</option> -->
              </select>
            </div>

            <!-- SSA Elements -->
            <div class="form-group">
              <label for="ssaElements">SSA Elements </label>
              <select
                id="ssaElements"
                class="form-control custom-select-picker"
                multiple
              >
                <!-- <option value="">Select SSA Elements</option> -->
              </select>
            </div>

            <!-- SSA Hierarchy -->
            <div class="form-group">
              <label>SSA Hierarchy</label>
              <div id="SSAHierarchy" class="checkbox-group">
                <!-- Checkboxes will be dynamically added here -->
              </div>
            </div>

            <button type="submit" class="btn btn-primary btn-block">
              Apply Filters
            </button>
            <button type="reset" class="btn btn-default btn-block">
              Clear
            </button>
          </form>
          <hr />
          <button
            type="button"
            id="showFavsOnlyBtn"
            class="btn btn-default btn-block"
          >
            Show favorites only
          </button>
        </aside>

        <!-- Main content column -->
        <section id="content" class="content col-md-9">
          <h2>Countermeasure Results</h2>
          <!-- <p id="totalCount" class="alert alert-success">
            Please select inputs from the left to filter countermeasures.
          </p> -->

          <form id="searchForm" class="form-horizontal" role="form">
            <div class="form-group">
              <!-- Search box (md-9) -->
              <div class="col-md-9 col-sm-8 col-xs-12">
                <input
                  type="text"
                  class="form-control"
                  id="searchInput"
                  placeholder="Search..."
                />
                <!-- Clear search link -->
                <small
                  id="clearSearch"
                  style="
                    cursor: pointer;
                    display: none;
                    color: #a94442;
                    border: 1px solid;
                    border-radius: 6px;
                    padding: 5px 10px;
                  "
                >
                  ✕ Clear search
                </small>
              </div>

              <!-- Search button (md-3) -->
              <div class="col-md-3 col-sm-4 col-xs-12">
                <button type="submit" class="btn btn-primary btn-block">
                  <span class="glyphicon glyphicon-search"></span> Search
                </button>
              </div>
            </div>
          </form>

          <div class="alert alert-success">
            <div class="pull-left">
              <span id="selectedCount">Selected: 0</span>
            </div>
            <div class="pull-right" id="exportButtons">
              <button id="selectAllBtn" class="btn btn-primary">
                Select All
              </button>
              <button id="exportTopBtnCsv" class="btn btn-primary">
                Export Selected to CSV
              </button>
            </div>
            <div class="clearfix"></div>
          </div>
          <div id="results" class="mt-3"></div>
        </section>
      </div>

      <!-- Overlay lives inside the same container -->
      <div id="sidebar-overlay" class="sidebar-overlay"></div>
      <!-- Fixed Export Buttons for Bottom Right -->
      <div class="fixed-buttons alert alert-success" id="fixedExportButtons">
        <p id="fixedSelectedCount" class="mb-1">Selected: 0</p>
        <button id="exportFixedBtnCsv" class="btn btn-primary mb-1">
          Export to CSV
        </button>
      </div>
    </main>

    <script>
      // Toggle sidebar on mobile
      $(document).on("click", ".sidebar-toggle", function () {
        var $sb = $("#sidebar");
        var $ov = $("#sidebar-overlay");
        var isOpen = $sb.hasClass("open");

        $sb.toggleClass("open", !isOpen);
        $ov.toggleClass("show", !isOpen);
        $(this).attr("aria-expanded", String(!isOpen));

        // Optional: hide top navbar collapse to avoid overlapping menus
        if (!isOpen) {
          $(".bs-navbar-collapse").collapse("hide");
        }
      });

      // Close sidebar when clicking overlay
      $(document).on("click", "#sidebar-overlay", function () {
        $("#sidebar").removeClass("open");
        $(this).removeClass("show");
        $(".sidebar-toggle").attr("aria-expanded", "false");
      });

      // Close with ESC
      $(document).on("keyup", function (e) {
        if (e.keyCode === 27) {
          $("#sidebar").removeClass("open");
          $("#sidebar-overlay").removeClass("show");
          $(".sidebar-toggle").attr("aria-expanded", "false");
        }
      });

      // Clean state when resizing up to md+
      $(window).on("resize", function () {
        if (window.matchMedia("(min-width: 992px)").matches) {
          $("#sidebar").removeClass("open");
          $("#sidebar-overlay").removeClass("show");
          $(".sidebar-toggle").attr("aria-expanded", "false");
        }
      });
    </script>
    <!-- Load the countermeasure data -->
    <!-- Data is loaded into window.CM_DATA -->
    <script src="data/data.js"></script>
    <script>
      $(document).ready(function () {
        console.log("Data loaded:", window.CM_DATA);

        // Global data variable
        let data = [];
        let allSelected = false; // Tracks select all state
        let filteredData = [];

        function initApp() {
          data = window.CM_DATA.map((item, index) => {
            return { ...item, index };
          });
          populateFilterOptions(data);
        }

        initApp();

        // ========================================================
        // Helper Functions
        // ========================================================

        // Function to capitalize first letter and make rest lowercase
        function capitalizeFirst(str) {
          if (!str) return str;
          return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }

        // Count occurrences from an array of labels (already cleaned/capitalized)
        function buildCounts(arr) {
          const counts = {};
          arr.forEach((v) => {
            if (!v) return;
            counts[v] = (counts[v] || 0) + 1;
          });
          return counts;
        }

        // Update select options with counts, sorted alphabetically
        function updateSelectWithCounts(selector, countsObj) {
          const $sel = $(selector);
          $sel.empty();
          Object.keys(countsObj)
            .sort((a, b) => a.localeCompare(b))
            .forEach((label) => {
              $sel.append(new Option(`${label} (${countsObj[label]})`, label));
            });
          $sel.val([]);

          // $sel.selectpicker("render");
          $sel.selectpicker("refresh");
        }
        // Update checkbox list with counts, sorted alphabetically
        function buildCheckboxList(selector, countsObj) {
          const $box = $(selector);
          $box.empty();
          Object.keys(countsObj)
            .sort((a, b) => a.localeCompare(b))
            .forEach((label) => {
              $box.append(
                `<label><input type="checkbox" name="${selector.replace(
                  "#",
                  ""
                )}" value="${label}"> ${label} (${countsObj[label]})</label>`
              );
            });
        }

        // ✅ Enable/disable existing SSAHierarchy checkboxes based on counts
        function updateCheckboxWithCounts(selector, countsObj) {
          const $box = $(selector);

          // Loop through each existing checkbox
          $box.find('input[type="checkbox"]').each(function () {
            const val = $(this).val();
            const count = countsObj[val] || 0;

            if (count > 0) {
              $(this)
                .prop("disabled", false)
                .closest("label")
                .removeClass("disabled");
            } else {
              $(this)
                .prop("disabled", true)
                .closest("label")
                .addClass("disabled");
            }

            // Update the count label text (e.g., "Urban (12)")
            const labelEl = $(this).closest("label");
            const baseText = val; // assuming label text is the value itself
            labelEl
              .contents()
              .filter(function () {
                return this.nodeType === 3;
              })
              .remove(); // remove old text nodes
            labelEl.append(` ${baseText} (${count})`);
          });
        }

        // Safe helpers for specific fields
        function firstContribFactor(s) {
          if (!s) return "";
          return s.split(",")[0].trim();
        }
        function cleanCap(v) {
          return capitalizeFirst((v || "").toString().trim());
        }

        // Safe refresh for bootstrap-select (no-op if not present)
        function refreshPicker(selector) {
          try {
            $(selector).selectpicker("refresh");
          } catch (e) {}
        }

        const norm = (v) => (v || "").toString().trim().toLowerCase();

        $(".custom-select-picker").selectpicker({
          showContent: true,
          actionsBox: true,
          showIcon: false,
          liveSearch: true,
          liveSearchNormalize: true,
        });

        // ========================================================
        // End Helper Functions
        // ========================================================

        // Populate filter options with unique values + counts (sorted)
        function populateFilterOptions(data) {
          // Collect values (simple, counts each occurrence)
          const focusAreaVals = [];
          const ssaHierarchyVals = [];
          const targetCrashVals = [];
          const areaTypeVals = [];
          const ssaElementVals = [];
          const contribFactorVals = [];

          data.forEach((item) => {
            focusAreaVals.push(cleanCap(item["Emphasis area"]));

            // ✅ Target Crash: CrashType1 + CrashType2 (avoid duplicates per row)
            const crash1 = cleanCap(item["CrashType1"]);
            const crash2 = cleanCap(item["CrashType2"]);
            console.log("Crash types:", crash1, crash2, crash1 === crash2);
            if (crash1 && crash2) {
              if (crash1 === crash2) {
                targetCrashVals.push(crash1);
              } else {
                targetCrashVals.push(crash1, crash2);
              }
            } else if (crash1) {
              targetCrashVals.push(crash1);
            } else if (crash2) {
              targetCrashVals.push(crash2);
            }

            // ✅ Land Use Type: AreaType1 + AreaType2 (avoid duplicates per row)
            const area1 = cleanCap(item["AreaType1"]);
            const area2 = cleanCap(item["AreaType2"]);
            console.log("Area types:", area1, area2,  area1 === area2);
            if (area1 && area2) {
              if (area1 === area2) {
                areaTypeVals.push(area1);
              } else {
                areaTypeVals.push(area1, area2);
              }
            } else if (area1) {
              areaTypeVals.push(area1);
            } else if (area2) {
              areaTypeVals.push(area2);
            }

            ssaElementVals.push(cleanCap(item["SSA Pillars"]));
            contribFactorVals.push(
              cleanCap(firstContribFactor(item["Contributing Factors"]))
            );
            ssaHierarchyVals.push(cleanCap(item["SSA Hierarchy"]));
          });

          // Build counts
          const focusAreaCounts = buildCounts(focusAreaVals);
          const targetCrashCounts = buildCounts(targetCrashVals);
          const areaTypeCounts = buildCounts(areaTypeVals);
          const ssaElementCounts = buildCounts(ssaElementVals);
          const contribFactorCounts = buildCounts(contribFactorVals);
          const ssaHierarchyCounts = buildCounts(ssaHierarchyVals);

          // Fill UI
          updateSelectWithCounts("#focusArea", focusAreaCounts);
          updateSelectWithCounts("#targetCrash", targetCrashCounts);
          updateSelectWithCounts("#contributingFactors", contribFactorCounts);
          updateSelectWithCounts("#areaType", areaTypeCounts);
          updateSelectWithCounts("#ssaElements", ssaElementCounts);
          buildCheckboxList("#SSAHierarchy", ssaHierarchyCounts);
          updateCheckboxWithCounts("#SSAHierarchy", ssaHierarchyCounts);

          // // Apply selections encoded in URL, then (only once) auto-submit
          // applySelectionsFromUrl();
          // autoSubmitFromUrlOnce();
        }

        $("#focusArea").on("change", function () {
          // 1) read all current selections (arrays, lowercased)
          const sel = {
            focus: ($("#focusArea").val() || []).map(norm),
            tc: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            at: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          console.log("Current selections:", sel);

          // 2) filter using all active selections (empty = pass)
          const filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const c1 = norm(d["CrashType1"]),
              c2 = norm(d["CrashType2"]);
            const a1 = norm(d["AreaType1"]),
              a2 = norm(d["AreaType2"]);
            const pil = norm(d["SSA Pillars"]);
            const hir = norm(d["SSA Hierarchy"]);
            const cf1 = norm(firstContribFactor(d["Contributing Factors"]));

            if (sel.focus.length && !sel.focus.includes(focus)) return false;
            if (sel.tc.length && !(sel.tc.includes(c1) || sel.tc.includes(c2)))
              return false;
            if (sel.cf.length && !sel.cf.includes(cf1)) return false;
            if (sel.at.length && !(sel.at.includes(a1) || sel.at.includes(a2)))
              return false;
            if (sel.ssae.length && !sel.ssae.includes(pil)) return false;
            if (sel.ssah.length && !sel.ssah.includes(hir)) return false;
            return true;
          });
          filteredData = filtered; // Store filtered data globally

          console.log("Filtered data count:", filtered.length);

          // / 3) rebuild option counts from filtered
          const tcVals = [],
            atVals = [],
            ssaeVals = [],
            cfVals = [],
            ssahVals = [];
          filtered.forEach((d) => {
            // focusVals.push(cleanCap(d["Emphasis area"]));
            // ✅ Target Crash Type: avoid duplicates per row
            const crash1 = cleanCap(d["CrashType1"]);
            const crash2 = cleanCap(d["CrashType2"]);
            if (crash1 && crash2) {
              if (crash1 === crash2) {
                tcVals.push(crash1);
              } else {
                tcVals.push(crash1, crash2);
              }
            } else if (crash1) {
              tcVals.push(crash1);
            } else if (crash2) {
              tcVals.push(crash2);
            }
            // ✅ Land Use Type: avoid duplicates per row
            const area1 = cleanCap(d["AreaType1"]);
            const area2 = cleanCap(d["AreaType2"]);
            if (area1 && area2) {
              if (area1 === area2) {
                atVals.push(area1);
              } else {
                atVals.push(area1, area2);
              }
            } else if (area1) {
              atVals.push(area1);
            } else if (area2) {
              atVals.push(area2);
            }
            ssaeVals.push(cleanCap(d["SSA Pillars"]));
            cfVals.push(
              cleanCap(firstContribFactor(d["Contributing Factors"]))
            );
            ssahVals.push(cleanCap(d["SSA Hierarchy"]));
          });

          // console.log("Focus Vals:", focusVals);
          console.log("TC Vals:", tcVals);
          console.log("AT Vals:", atVals);
          console.log("SSAE Vals:", ssaeVals);
          console.log("CF Vals:", cfVals);
          console.log("SSAH Vals:", ssahVals);

          // Build counts
          // const focusCounts = buildCounts(focusVals);
          const tcCounts = buildCounts(tcVals);
          const atCounts = buildCounts(atVals);
          const ssaElementCounts = buildCounts(ssaeVals);
          const contribFactorCounts = buildCounts(cfVals);
          const ssaHierarchyCounts = buildCounts(ssahVals);

          // 4) update UI (uses your existing updaters)
          // updateSelectWithCounts("#focusArea", focusCounts);
          updateSelectWithCounts("#targetCrash", tcCounts);
          updateSelectWithCounts("#contributingFactors", contribFactorCounts);
          updateSelectWithCounts("#areaType", atCounts);
          updateSelectWithCounts("#ssaElements", ssaElementCounts);
          updateCheckboxWithCounts("#SSAHierarchy", ssaHierarchyCounts);
        });

        $("#targetCrash").on("change", function () {
          // 1) read all current selections (arrays, lowercased)
          const sel = {
            focus: ($("#focusArea").val() || []).map(norm),
            tc: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            at: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          console.log("Current selections:", sel);

          // 2) filter using all active selections (empty = pass)
          const filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const c1 = norm(d["CrashType1"]),
              c2 = norm(d["CrashType2"]);
            const a1 = norm(d["AreaType1"]),
              a2 = norm(d["AreaType2"]);
            const pil = norm(d["SSA Pillars"]);
            const hir = norm(d["SSA Hierarchy"]);
            const cf1 = norm(firstContribFactor(d["Contributing Factors"]));

            if (sel.focus.length && !sel.focus.includes(focus)) return false;
            if (sel.tc.length && !(sel.tc.includes(c1) || sel.tc.includes(c2)))
              return false;
            if (sel.cf.length && !sel.cf.includes(cf1)) return false;
            if (sel.at.length && !(sel.at.includes(a1) || sel.at.includes(a2)))
              return false;
            if (sel.ssae.length && !sel.ssae.includes(pil)) return false;
            if (sel.ssah.length && !sel.ssah.includes(hir)) return false;
            return true;
          });
          console.log("Filtered data count:", filtered.length);
          filteredData = filtered; // Store filtered data globally

          // 3) rebuild option counts from filtered
          const focusVals = [],
            atVals = [],
            ssaeVals = [],
            cfVals = [],
            ssahVals = [];
          filtered.forEach((d) => {
            focusVals.push(cleanCap(d["Emphasis area"]));
            // ✅ Land Use Type: avoid duplicates per row
            const area1 = cleanCap(d["AreaType1"]);
            const area2 = cleanCap(d["AreaType2"]);
            if (area1 && area2) {
              if (area1 === area2) {
                atVals.push(area1);
              } else {
                atVals.push(area1, area2);
              }
            } else if (area1) {
              atVals.push(area1);
            } else if (area2) {
              atVals.push(area2);
            }
            ssaeVals.push(cleanCap(d["SSA Pillars"]));
            cfVals.push(
              cleanCap(firstContribFactor(d["Contributing Factors"]))
            );
            ssahVals.push(cleanCap(d["SSA Hierarchy"]));
          });

          // Build counts
          const focusCounts = buildCounts(focusVals);
          const atCounts = buildCounts(atVals);
          const ssaElementCounts = buildCounts(ssaeVals);
          const contribFactorCounts = buildCounts(cfVals);
          const ssaHierarchyCounts = buildCounts(ssahVals);

          // 4) ✅ Only update dropdowns with NO current selection
          if (sel.focus.length === 0) {
            updateSelectWithCounts("#focusArea", focusCounts);
          }
          if (sel.cf.length === 0) {
            updateSelectWithCounts("#contributingFactors", contribFactorCounts);
          }
          if (sel.at.length === 0) {
            updateSelectWithCounts("#areaType", atCounts);
          }
          if (sel.ssae.length === 0) {
            updateSelectWithCounts("#ssaElements", ssaElementCounts);
          }
          if (sel.ssah.length === 0) {
            updateCheckboxWithCounts("#SSAHierarchy", ssaHierarchyCounts);
          }
        });

        $("#contributingFactors").on("change", function () {
          // 1) read all current selections (arrays, lowercased)
          const sel = {
            focus: ($("#focusArea").val() || []).map(norm),
            tc: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            at: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          console.log("Current selections:", sel);

          // 2) filter using all active selections (empty = pass)
          const filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const c1 = norm(d["CrashType1"]),
              c2 = norm(d["CrashType2"]);
            const a1 = norm(d["AreaType1"]),
              a2 = norm(d["AreaType2"]);
            const pil = norm(d["SSA Pillars"]);
            const hir = norm(d["SSA Hierarchy"]);
            const cf1 = norm(firstContribFactor(d["Contributing Factors"]));

            if (sel.focus.length && !sel.focus.includes(focus)) return false;
            if (sel.tc.length && !(sel.tc.includes(c1) || sel.tc.includes(c2)))
              return false;
            if (sel.cf.length && !sel.cf.includes(cf1)) return false;
            if (sel.at.length && !(sel.at.includes(a1) || sel.at.includes(a2)))
              return false;
            if (sel.ssae.length && !sel.ssae.includes(pil)) return false;
            if (sel.ssah.length && !sel.ssah.includes(hir)) return false;
            return true;
          });
          console.log("Filtered data count:", filtered.length);
          filteredData = filtered; // Store filtered data globally

          // 3) rebuild option counts from filtered
          const focusVals = [],
            tcVals = [],
            atVals = [],
            ssaeVals = [],
            cfVals = [],
            ssahVals = [];
          filtered.forEach((d) => {
            focusVals.push(cleanCap(d["Emphasis area"]));
            // ✅ Target Crash Type: avoid duplicates per row
            const crash1 = cleanCap(d["CrashType1"]);
            const crash2 = cleanCap(d["CrashType2"]);
            if (crash1 && crash2) {
              if (crash1 === crash2) {
                tcVals.push(crash1);
              } else {
                tcVals.push(crash1, crash2);
              }
            } else if (crash1) {
              tcVals.push(crash1);
            } else if (crash2) {
              tcVals.push(crash2);
            }
            // ✅ Land Use Type: avoid duplicates per row
            const area1 = cleanCap(d["AreaType1"]);
            const area2 = cleanCap(d["AreaType2"]);
            if (area1 && area2) {
              if (area1 === area2) {
                atVals.push(area1);
              } else {
                atVals.push(area1, area2);
              }
            } else if (area1) {
              atVals.push(area1);
            } else if (area2) {
              atVals.push(area2);
            }
            ssaeVals.push(cleanCap(d["SSA Pillars"]));
            cfVals.push(
              cleanCap(firstContribFactor(d["Contributing Factors"]))
            );
            ssahVals.push(cleanCap(d["SSA Hierarchy"]));
          });

          // Build counts
          const focusCounts = buildCounts(focusVals);
          const targetCrashCounts = buildCounts(tcVals);
          const atCounts = buildCounts(atVals);
          const ssaElementCounts = buildCounts(ssaeVals);
          // const contribFactorCounts = buildCounts(cfVals);
          const ssaHierarchyCounts = buildCounts(ssahVals);

          // 4) ✅ Only update dropdowns with NO current selection
          if (sel.focus.length === 0) {
            updateSelectWithCounts("#focusArea", focusCounts);
          }
          if (sel.tc.length === 0) {
            updateSelectWithCounts("#targetCrash", targetCrashCounts);
          }
          if (sel.at.length === 0) {
            updateSelectWithCounts("#areaType", atCounts);
          }
          if (sel.ssae.length === 0) {
            updateSelectWithCounts("#ssaElements", ssaElementCounts);
          }
          if (sel.ssah.length === 0) {
            updateCheckboxWithCounts("#SSAHierarchy", ssaHierarchyCounts);
          }
        });

        $("#areaType").on("change", function () {
          // 1) read all current selections (arrays, lowercased)
          const sel = {
            focus: ($("#focusArea").val() || []).map(norm),
            tc: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            at: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          console.log("Current selections:", sel);

          // 2) filter using all active selections (empty = pass)
          const filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const c1 = norm(d["CrashType1"]),
              c2 = norm(d["CrashType2"]);
            const a1 = norm(d["AreaType1"]),
              a2 = norm(d["AreaType2"]);
            const pil = norm(d["SSA Pillars"]);
            const hir = norm(d["SSA Hierarchy"]);
            const cf1 = norm(firstContribFactor(d["Contributing Factors"]));

            if (sel.focus.length && !sel.focus.includes(focus)) return false;
            if (sel.tc.length && !(sel.tc.includes(c1) || sel.tc.includes(c2)))
              return false;
            if (sel.cf.length && !sel.cf.includes(cf1)) return false;
            if (sel.at.length && !(sel.at.includes(a1) || sel.at.includes(a2)))
              return false;
            if (sel.ssae.length && !sel.ssae.includes(pil)) return false;
            if (sel.ssah.length && !sel.ssah.includes(hir)) return false;
            return true;
          });
          console.log("Filtered data count:", filtered.length);
          filteredData = filtered; // Store filtered data globally

          // 3) rebuild option counts from filtered
          const focusVals = [],
            tcVals = [],
            atVals = [],
            ssaeVals = [],
            cfVals = [],
            ssahVals = [];
          filtered.forEach((d) => {
            focusVals.push(cleanCap(d["Emphasis area"]));
            // ✅ Target Crash Type: avoid duplicates per row
            const crash1 = cleanCap(d["CrashType1"]);
            const crash2 = cleanCap(d["CrashType2"]);
            if (crash1 && crash2) {
              if (crash1 === crash2) {
                tcVals.push(crash1);
              } else {
                tcVals.push(crash1, crash2);
              }
            } else if (crash1) {
              tcVals.push(crash1);
            } else if (crash2) {
              tcVals.push(crash2);
            }
            // ✅ Land Use Type: avoid duplicates per row
            const area1 = cleanCap(d["AreaType1"]);
            const area2 = cleanCap(d["AreaType2"]);
            if (area1 && area2) {
              if (area1 === area2) {
                atVals.push(area1);
              } else {
                atVals.push(area1, area2);
              }
            } else if (area1) {
              atVals.push(area1);
            } else if (area2) {
              atVals.push(area2);
            }
            ssaeVals.push(cleanCap(d["SSA Pillars"]));
            cfVals.push(
              cleanCap(firstContribFactor(d["Contributing Factors"]))
            );
            ssahVals.push(cleanCap(d["SSA Hierarchy"]));
          });

          // Build counts
          const focusCounts = buildCounts(focusVals);
          const targetCrashCounts = buildCounts(tcVals);
          // const atCounts = buildCounts(atVals);
          const ssaElementCounts = buildCounts(ssaeVals);
          const contribFactorCounts = buildCounts(cfVals);
          const ssaHierarchyCounts = buildCounts(ssahVals);

          // 4) ✅ Only update dropdowns with NO current selection
          if (sel.focus.length === 0) {
            updateSelectWithCounts("#focusArea", focusCounts);
          }
          if (sel.tc.length === 0) {
            updateSelectWithCounts("#targetCrash", targetCrashCounts);
          }
          if (sel.ssae.length === 0) {
            updateSelectWithCounts("#ssaElements", ssaElementCounts);
          }
          if (sel.cf.length === 0) {
            updateSelectWithCounts("#contributingFactors", contribFactorCounts);
          }
          if (sel.ssah.length === 0) {
            updateCheckboxWithCounts("#SSAHierarchy", ssaHierarchyCounts);
          }
        });

        $("#ssaElements").on("change", function () {
          // 1) read all current selections (arrays, lowercased)
          const sel = {
            focus: ($("#focusArea").val() || []).map(norm),
            tc: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            at: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          console.log("Current selections:", sel);

          // 2) filter using all active selections (empty = pass)
          const filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const c1 = norm(d["CrashType1"]),
              c2 = norm(d["CrashType2"]);
            const a1 = norm(d["AreaType1"]),
              a2 = norm(d["AreaType2"]);
            const pil = norm(d["SSA Pillars"]);
            const hir = norm(d["SSA Hierarchy"]);
            const cf1 = norm(firstContribFactor(d["Contributing Factors"]));

            if (sel.focus.length && !sel.focus.includes(focus)) return false;
            if (sel.tc.length && !(sel.tc.includes(c1) || sel.tc.includes(c2)))
              return false;
            if (sel.cf.length && !sel.cf.includes(cf1)) return false;
            if (sel.at.length && !(sel.at.includes(a1) || sel.at.includes(a2)))
              return false;
            if (sel.ssae.length && !sel.ssae.includes(pil)) return false;
            if (sel.ssah.length && !sel.ssah.includes(hir)) return false;
            return true;
          });
          console.log("Filtered data count:", filtered.length);
          filteredData = filtered; // Store filtered data globally

          // 3) rebuild option counts from filtered
          const focusVals = [],
            tcVals = [],
            atVals = [],
            ssaeVals = [],
            cfVals = [],
            ssahVals = [];
          filtered.forEach((d) => {
            focusVals.push(cleanCap(d["Emphasis area"]));
            // ✅ Target Crash Type: avoid duplicates per row
            const crash1 = cleanCap(d["CrashType1"]);
            const crash2 = cleanCap(d["CrashType2"]);
            if (crash1 && crash2) {
              if (crash1 === crash2) {
                tcVals.push(crash1);
              } else {
                tcVals.push(crash1, crash2);
              }
            } else if (crash1) {
              tcVals.push(crash1);
            } else if (crash2) {
              tcVals.push(crash2);
            }
            // ✅ Land Use Type: avoid duplicates per row
            const area1 = cleanCap(d["AreaType1"]);
            const area2 = cleanCap(d["AreaType2"]);
            if (area1 && area2) {
              if (area1 === area2) {
                atVals.push(area1);
              } else {
                atVals.push(area1, area2);
              }
            } else if (area1) {
              atVals.push(area1);
            } else if (area2) {
              atVals.push(area2);
            }
            ssaeVals.push(cleanCap(d["SSA Pillars"]));
            cfVals.push(
              cleanCap(firstContribFactor(d["Contributing Factors"]))
            );
            ssahVals.push(cleanCap(d["SSA Hierarchy"]));
          });

          // Build counts
          const focusCounts = buildCounts(focusVals);
          const targetCrashCounts = buildCounts(tcVals);
          const atCounts = buildCounts(atVals);
          // const ssaElementCounts = buildCounts(ssaeVals);
          const contribFactorCounts = buildCounts(cfVals);
          const ssaHierarchyCounts = buildCounts(ssahVals);

          // 4) ✅ Only update dropdowns with NO current selection
          if (sel.focus.length === 0) {
            updateSelectWithCounts("#focusArea", focusCounts);
          }
          if (sel.tc.length === 0) {
            updateSelectWithCounts("#targetCrash", targetCrashCounts);
          }
          if (sel.at.length === 0) {
            updateSelectWithCounts("#areaType", atCounts);
          }
          if (sel.cf.length === 0) {
            updateSelectWithCounts("#contributingFactors", contribFactorCounts);
          }
          if (sel.ssah.length === 0) {
            updateCheckboxWithCounts("#SSAHierarchy", ssaHierarchyCounts);
          }
        });

        $("#SSAHierarchy input[type=checkbox]").on("change", function () {
          // 1) read all current selections (arrays, lowercased)
          const sel = {
            focus: ($("#focusArea").val() || []).map(norm),
            tc: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            at: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          console.log("Current selections:", sel);

          // 2) filter using all active selections (empty = pass)
          const filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const c1 = norm(d["CrashType1"]),
              c2 = norm(d["CrashType2"]);
            const a1 = norm(d["AreaType1"]),
              a2 = norm(d["AreaType2"]);
            const pil = norm(d["SSA Pillars"]);
            const hir = norm(d["SSA Hierarchy"]);
            const cf1 = norm(firstContribFactor(d["Contributing Factors"]));

            if (sel.focus.length && !sel.focus.includes(focus)) return false;
            if (sel.tc.length && !(sel.tc.includes(c1) || sel.tc.includes(c2)))
              return false;
            if (sel.cf.length && !sel.cf.includes(cf1)) return false;
            if (sel.at.length && !(sel.at.includes(a1) || sel.at.includes(a2)))
              return false;
            if (sel.ssae.length && !sel.ssae.includes(pil)) return false;
            if (sel.ssah.length && !sel.ssah.includes(hir)) return false;
            return true;
          });
          console.log("Filtered data count:", filtered.length);
          filteredData = filtered; // Store filtered data globally

          // 3) rebuild option counts from filtered
          const focusVals = [],
            tcVals = [],
            atVals = [],
            ssaeVals = [],
            cfVals = [],
            ssahVals = [];
          filtered.forEach((d) => {
            focusVals.push(cleanCap(d["Emphasis area"]));
            // ✅ Target Crash Type: avoid duplicates per row
            const crash1 = cleanCap(d["CrashType1"]);
            const crash2 = cleanCap(d["CrashType2"]);
            if (crash1 && crash2) {
              if (crash1 === crash2) {
                tcVals.push(crash1);
              } else {
                tcVals.push(crash1, crash2);
              }
            } else if (crash1) {
              tcVals.push(crash1);
            } else if (crash2) {
              tcVals.push(crash2);
            }
            // ✅ Land Use Type: avoid duplicates per row
            const area1 = cleanCap(d["AreaType1"]);
            const area2 = cleanCap(d["AreaType2"]);
            if (area1 && area2) {
              if (area1 === area2) {
                atVals.push(area1);
              } else {
                atVals.push(area1, area2);
              }
            } else if (area1) {
              atVals.push(area1);
            } else if (area2) {
              atVals.push(area2);
            }
            ssaeVals.push(cleanCap(d["SSA Pillars"]));
            cfVals.push(
              cleanCap(firstContribFactor(d["Contributing Factors"]))
            );
            ssahVals.push(cleanCap(d["SSA Hierarchy"]));
          });

          // Build counts
          const focusCounts = buildCounts(focusVals);
          const targetCrashCounts = buildCounts(tcVals);
          const atCounts = buildCounts(atVals);
          const ssaElementCounts = buildCounts(ssaeVals);
          const contribFactorCounts = buildCounts(cfVals);
          // const ssaHierarchyCounts = buildCounts(ssahVals);

          // 4) ✅ Only update dropdowns with NO current selection
          if (sel.focus.length === 0) {
            updateSelectWithCounts("#focusArea", focusCounts);
          }
          if (sel.tc.length === 0) {
            updateSelectWithCounts("#targetCrash", targetCrashCounts);
          }
          if (sel.at.length === 0) {
            updateSelectWithCounts("#areaType", atCounts);
          }
          if (sel.ssae.length === 0) {
            updateSelectWithCounts("#ssaElements", ssaElementCounts);
          }
          if (sel.cf.length === 0) {
            updateSelectWithCounts("#contributingFactors", contribFactorCounts);
          }
        });

        $("#filterForm").on("reset", function () {
          setTimeout(() => {
            // Clear all selections
            $(".custom-select-picker").val([]);
            refreshPicker(".custom-select-picker");
            $("#SSAHierarchy input[type=checkbox]").prop("checked", false);
            // Repopulate options with full data counts
            populateFilterOptions(data);
            filteredData = data; // Reset filtered data
            console.log("Filters cleared, full data restored.");
            const state = readFilterState();
            updateUrlWithFilters(state);
          }, 0);
          filteredData = [];
          $("#results").empty();
          $("h2:contains('Countermeasure Results')").text(
            `Countermeasure Results`
          );
          $("#selectedCount").text("Selected: 0");
          $("#fixedSelectedCount").text("Selected: 0");
          $("#fixedExportButtons").fadeOut();
          allSelected = false;
          $("#selectAllBtn").text("Select All");
        });

        // Apply filters to display results
        $("#filterForm").submit(function (e) {
          e.preventDefault();
          const state = readFilterState();
          updateUrlWithFilters(state);
          const fd = getFilteredData();
          filteredData = fd;
          console.log(filteredData.length);
          displayResults(filteredData);
        });

        // 🔍 handle search submit
        $("#searchForm").on("submit", function (e) {
          e.preventDefault();
          // 1) read current filter state & sync URL
          const state = readFilterState();
          updateUrlWithFilters(state); // use {replace:true} if you don't want history entries
          const fd = getFilteredData();
          filteredData = fd;
          console.log(filteredData.length);
          displayResults(filteredData);
          console.log("Search filtered count:", filteredData.length);
        });

        // ✕ handle clear search
        $("#clearSearch").on("click", function () {
          $("#searchInput").val("");
          $(this).hide();
          const state = readFilterState(); // uses your helper from earlier
          updateUrlWithFilters(state, { replace: true });
          const fd = getFilteredData();
          filteredData = fd;
          console.log(filteredData.length);
          displayResults(filteredData);
        });

        // ✅ Main filter function
        function getFilteredData() {
          // 1) Collect all selected values
          const selected = {
            focus: ($("#focusArea").val() || []).map(norm),
            target: ($("#targetCrash").val() || []).map(norm),
            cf: ($("#contributingFactors").val() || []).map(norm),
            area: ($("#areaType").val() || []).map(norm),
            ssae: ($("#ssaElements").val() || []).map(norm),
            ssah: $("#SSAHierarchy input[type=checkbox]:checked")
              .map(function () {
                return norm($(this).val());
              })
              .get(),
          };

          // 2) Filter the data based on selections (AND search, skip empty)
          let filtered = data.filter((d) => {
            const focus = norm(d["Emphasis area"]);
            const crash1 = norm(d["CrashType1"]);
            const crash2 = norm(d["CrashType2"]);
            const cf1 = norm((d["Contributing Factors"] || "").split(",")[0]);
            const a1 = norm(d["AreaType1"]);
            const a2 = norm(d["AreaType2"]);
            const ssae = norm(d["SSA Pillars"]);
            const ssah = norm(d["SSA Hierarchy"]);

            if (selected.focus.length && !selected.focus.includes(focus))
              return false;
            if (
              selected.target.length &&
              !(
                selected.target.includes(crash1) ||
                selected.target.includes(crash2)
              )
            )
              return false;
            if (selected.cf.length && !selected.cf.includes(cf1)) return false;
            if (
              selected.area.length &&
              !(selected.area.includes(a1) || selected.area.includes(a2))
            )
              return false;
            if (selected.ssae.length && !selected.ssae.includes(ssae))
              return false;
            if (selected.ssah.length && !selected.ssah.includes(ssah))
              return false;

            return true;
          });

          console.log(`Filtered data count: ${filtered.length}`);

          const query = norm($("#searchInput").val());

          if (!query) {
            $("#clearSearch").hide(); // hide clear link when empty
          } else {
            filtered = filtered.filter((item) => {
              return (
                norm(item["Emphasis area"]).includes(query) ||
                norm(item["CrashType1"]).includes(query) ||
                norm(item["CrashType2"]).includes(query) ||
                norm(item["AreaType1"]).includes(query) ||
                norm(item["AreaType2"]).includes(query) ||
                norm(item["Contributing Factors"]).includes(query) ||
                norm(item["SSA Pillars"]).includes(query) ||
                norm(item["SSA Hierarchy"]).includes(query)
              );
            });
            $("#clearSearch").show(); // show clear link after search
          }

          return filtered;
        }

        // Helpers to read current UI state
        function getVals(sel) {
          const v = $(sel).val();
          return Array.isArray(v) ? v : v ? [v] : [];
        }
        function getChecked(container) {
          return $(container)
            .find("input[type=checkbox]:checked")
            .map(function () {
              return $(this).val();
            })
            .get();
        }

        // Read all filters into a plain object
        function readFilterState() {
          return {
            focusArea: getVals("#focusArea"),
            targetCrash: getVals("#targetCrash"),
            contributingFactors: getVals("#contributingFactors"),
            areaType: getVals("#areaType"),
            ssaElements: getVals("#ssaElements"),
            ssah: getChecked("#SSAHierarchy"),
            q: ($("#searchInput").val() || "").trim(), // optional search box
          };
        }

        // ✅ Detect if any filter/search is active
        function hasAnyFilters(state) {
          if (!state) return false;

          const arrKeys = [
            "focusArea",
            "targetCrash",
            "contributingFactors",
            "areaType",
            "ssaElements",
            "ssah",
          ];
          const anyArrayHasValue = arrKeys.some(
            (k) =>
              Array.isArray(state[k]) &&
              state[k].some((v) => String(v).trim() !== "")
          );

          const hasQuery = state.q && String(state.q).trim() !== "";

          return anyArrayHasValue || hasQuery;
        }

        // Only write when there is something to write unless allowEmpty=true
        function updateUrlWithFilters(
          state,
          { replace = false, allowEmpty = false } = {}
        ) {
          if (!allowEmpty && !hasAnyFilters(state)) return; // <-- prevents "clear URL" on init/submit

          const url = new URL(window.location.href);
          const params = new URLSearchParams();

          Object.entries(state).forEach(([key, val]) => {
            if (Array.isArray(val)) {
              val
                .filter((v) => String(v).trim() !== "")
                .forEach((v) => params.append(key, v));
            } else if (val != null && String(val).trim() !== "") {
              params.set(key, val);
            }
          });

          url.search = params.toString();
          replace
            ? history.replaceState(null, "", url)
            : history.pushState(null, "", url);
        }

        // ---------- URL <-> UI ----------
        function getUrlFilterState() {
          const params = new URLSearchParams(window.location.search);
          const arr = (k) => {
            const all = params.getAll(k);
            return all.length === 1 && all[0].indexOf(",") !== -1
              ? all[0]
                  .split(",")
                  .map((s) => s.trim())
                  .filter(Boolean)
              : all;
          };
          return {
            focusArea: arr("focusArea"),
            targetCrash: arr("targetCrash"),
            contributingFactors: arr("contributingFactors"),
            areaType: arr("areaType"),
            ssaElements: arr("ssaElements"),
            ssah: arr("ssah"),
            q: (params.get("q") || "").trim(),
          };
        }

        // ---------- Apply URL to UI ----------
        function applySelectionsFromUrl() {
          const st = getUrlFilterState();

          const setSelect = (selector, values) => {
            const $sel = $(selector);
            const v = Array.isArray(values) ? values : values ? [values] : [];
            if (!v.length) {
              $sel.val([]);
              if ($sel.selectpicker) $sel.selectpicker("refresh");
              return;
            }
            const existing = new Set(
              $sel
                .find("option")
                .map(function () {
                  return $(this).val();
                })
                .get()
            );
            const valid = v.filter((x) => existing.has(x));
            $sel.val(valid);
            if ($sel.selectpicker) $sel.selectpicker("refresh");
          };

          setSelect("#focusArea", st.focusArea);
          setSelect("#targetCrash", st.targetCrash);
          setSelect("#contributingFactors", st.contributingFactors);
          setSelect("#areaType", st.areaType);
          setSelect("#ssaElements", st.ssaElements);

          const ssahSet = new Set((st.ssah || []).map(String));
          $("#SSAHierarchy input[type=checkbox]").each(function () {
            $(this).prop("checked", ssahSet.has($(this).val()));
          });

          if (st.q) {
            $("#searchInput").val(st.q);
            $("#clearSearch").show();
          } else {
            $("#searchInput").val("");
            $("#clearSearch").hide();
          }
        }

        function hasAnyFilters(state) {
          if (!state) return false;
          const keys = [
            "focusArea",
            "targetCrash",
            "contributingFactors",
            "areaType",
            "ssaElements",
            "ssah",
          ];
          const anyArrays = keys.some(
            (k) => Array.isArray(state[k]) && state[k].length > 0
          );
          const hasQ = !!(state.q && state.q.trim());
          return anyArrays || hasQ;
        }

        // ---------- Populate helpers: only update if empty ----------
        function selectHasSelection(selector) {
          const v = $(selector).val();
          return Array.isArray(v) ? v.length > 0 : !!v;
        }

        function updateSelectIfEmpty(selector, countsObj) {
          if (selectHasSelection(selector)) return; // don't wipe user/URL choices
          updateSelectWithCounts(selector, countsObj); // your existing function that clears & fills
        }

        function checkboxGroupHasSelection(selector) {
          return $(selector).find("input[type=checkbox]:checked").length > 0;
        }

        function updateCheckboxIfEmpty(selector, countsObj) {
          if (checkboxGroupHasSelection(selector)) return;
          updateCheckboxWithCounts(selector, countsObj); // your enable/disable updater
        }

        // ---------- One-time auto submit ----------
        let didAutoSubmitFromUrl = false;
        function autoSubmitFromUrlOnce() {
          if (didAutoSubmitFromUrl) return;
          const st = getUrlFilterState();
          if (hasAnyFilters(st)) {
            didAutoSubmitFromUrl = true;
            // Prefer filter submit first; then search if q present
            if ($("#filterForm").length) $("#filterForm").trigger("submit");
            if (st.q && $("#searchForm").length)
              $("#searchForm").trigger("submit");
          }
        }

        // Display full details for each filtered item, show total count, and add checkboxes
        function displayResults(filteredData) {
          console.log("Filtered Data Length:", filteredData.length);
          console.log("Filtered Data:", filteredData);

          $("#results").empty();

          // Update the Countermeasure Results count
          var itemLabel = filteredData.length === 1 ? "item" : "items";
          $("h2:contains('Countermeasure Results')").text(
            `Countermeasure Results (showing ${filteredData.length} ${itemLabel})`
          );

          filteredData.forEach((item, index) => {
            let cmfId = item["CMF1 Link"]
              ? item["CMF1 Link"]
                  .replace(/^CMF/, "") // Remove 'CMF' prefix
                  .replace(/\s+/g, "-") // Replace spaces with hyphens (if any)
                  .toLowerCase()
              : ""; // Convert to lowercase (optional)
            console.log("CMF ID:", cmfId);

            const kbQuery = encodeURIComponent(
              item["Keyword_OnlyForTool"] || ""
            );
            const cmfIdSafe =
              typeof cmfId !== "undefined" && cmfId ? cmfId : null;
            const itemId = getItemId(item);
            const favChecked = isFav(itemId) ? "checked" : "";

            const cardTopContent = `
              <div class="panel panel-default selectable-card panel-mt" data-index="${
                item.index
              }" data-countermeasure="${item.Countermeasure}">
                <div class="panel-body card-content">
                  <div class="row" style="display:flex; align-items:stretch;">
                    <!-- Checkbox column with vertical separator -->
                    <div class="col-xs-2 col-sm-1 text-center"
                        style="border-right:1px solid #ddd; display:flex; align-items:center; justify-content:center; padding:6px 0;">
                      <input type="checkbox"
                            class="select-item"
                            aria-label="Select countermeasure"
                            data-index="${item.index}"
                            data-countermeasure="${item.Countermeasure}">
                    </div>

                    <!-- Main content -->
                    <div class="col-xs-10 col-sm-11">
                      <div class="row">
                        <div class="col-md-9 card-text-content">
                          <p><strong>Countermeasure:</strong> ${
                            item.Countermeasure || "N/A"
                          }</p>
                          <p><strong>Type:</strong> ${
                            item["Countermeasure Staus_OnlyforTool"] || "N/A"
                          }</p>
                          <p><strong>SSA Element:</strong> ${
                            item["SSA Pillars"] || "N/A"
                          }</p>
                          <p><strong>TZD:</strong> ${
                            item["AASHTO"] || "N/A"
                          }</p>
                          <p><strong>SSA Hierarchy:</strong> ${
                            item["SSA Hierarchy"] || "N/A"
                          }</p>
                          <p><strong>Emphasis Area:</strong> ${
                            item["Emphasis area"] || "N/A"
                          }</p>
                          <p><strong>Target Crash Type:</strong> 
                            ${
                              (() => {
                                const v1 = item["CrashType1"]?.trim();
                                const v2 = item["CrashType2"]?.trim();

                                if (v1 && v2) {
                                  if (v1 === v2) {
                                    return v1;
                                  } else {
                                    return `${v1} (CMF1), ${v2} (CMF2)`;
                                  }
                                } else if (v1) {
                                  return `${v1} (CMF1)`;
                                } else if (v2) {
                                  return `${v2} (CMF2)`;
                                } else {
                                  return "N/A";
                                }
                              })()
                            }
                          </p>

                          <p><strong>Land Use Type:</strong> 
                            ${
                              (() => {
                                const v1 = item["AreaType1"]?.trim();
                                const v2 = item["AreaType2"]?.trim();

                                if (v1 && v2) {
                                  if (v1 === v2) {
                                    return v1;
                                  } else {
                                    return `${v1} (CMF1), ${v2} (CMF2)`;
                                  }
                                } else if (v1) {
                                  return `${v1} (CMF1)`;
                                } else if (v2) {
                                  return `${v2} (CMF2)`;
                                } else {
                                  return "N/A";
                                }
                              })()
                            }
                          </p>
                          <p><strong>Contributing Factors:</strong> ${
                            item["Contributing Factors"] || "N/A"
                          }</p>
                        </div>

                        <div class="col-md-3 card-img-content" >
                          <a href="../core/images/countermeasures/${
                            item["img"]
                          }" data-lightbox="${item["CountermeasureID"]}-${
              item.Countermeasure
            }" data-title="${item["CountermeasureID"]}-${item.Countermeasure}">
                            <img src="../core/images/countermeasures/${
                              item["img"]
                            }"
                                alt="Countermeasure image"
                                class="img-responsive pull-right">
                            <p>Click to expand photo</p>
                          </a>
                        </div>
                      </div>

                      <div class="card-bottom-content" style="margin-top:10px;">
                        <div class="row">
                          <div class="col-md-12">
                            <p><strong>CMF:</strong> ${
                              (() => {
                                const c1 = parseFloat(item.CMF1);
                                const c2 = parseFloat(item.CMF2);

                                if (!isNaN(c1) && !isNaN(c2)) {
                                  if (c1 === c2) {
                                    return `${c1} (CMF1 & CMF2)`;
                                  } else if (c1 < c2) {
                                    return `[${c1} (CMF1) - ${c2} (CMF2)]`;
                                  } else {
                                    return `[${c2} (CMF2) - ${c1} (CMF1)]`;
                                  }
                                } else if (!isNaN(c1)) {
                                  return `${c1} (CMF1)`;
                                } else if (!isNaN(c2)) {
                                  return `${c2} (CMF2)`;
                                } else {
                                  return "N/A";
                                }
                              })()
                            }</p>
                            <p><strong>NCHRP 500 Series Objective:</strong> ${
                              item["NCHRP 500 Series Objective"] || "N/A"
                            }</p>
                            <span style="color:red">Note: This is guidance only. States can select their own countermeasures.</span>

                            <p style="margin-top:15px; margin-bottom:15px;">
                              ${
                                cmfIdSafe
                                  ? `
                                <a href="https://cmfclearinghouse.fhwa.dot.gov/detail.php?facid=${cmfIdSafe}"
                                  target="_blank" style="background-color:lightgray;display:inline-block;padding:5px 10px;color:black;">CMF Clearinghouse <i class="fa fa-external-link" aria-hidden="true"></i></a>`
                                  : ``
                              }
                              <a href="resource.htm?q=${kbQuery}" target="_blank" style="background-color:lightblue;display:inline-block;padding:5px 10px;color:black;">Resource Library <i class="fa fa-external-link" aria-hidden="true"></i></a>
                              <a href="factsheets/${
                                item["CountermeasureID"]
                              }.pdf" target="_blank" style="background-color:lightgreen;display:inline-block;padding:5px 10px;color:black;">Countermeasure Fact Sheet <i class="fa fa-external-link" aria-hidden="true"></i></a>
                            </p>
                          </div>

                          <div class="col-md-4">
                            <p><strong>Cost:</strong> ${
                              item["Cost"] || "N/A"
                            }</p>
                            <p><strong>Service Life:</strong> ${
                              item["Service Life"] &&
                              item["Service Life"]
                                .toString()
                                .trim()
                                .toUpperCase() !== "N/A"
                                ? `${item["Service Life"]} years`
                                : "N/A"
                            }</p>
                            <p><strong>Implementation Time:</strong> ${
                              item["Implementation Time"] || "N/A"
                            }</p>
                          </div>

                          <div class="col-md-8">
                            <p><strong>Redundancy-Driven Countermeasures</strong></p>
                            <ol>
                              <li><p>${item["Countermeasure 1"] || "N/A"}</p></li>
                              <li><p>${item["Countermeasure 2"] || "N/A"}</p></li>
                              <li><p>${item["Countermeasure 3"] || "N/A"}</p></li>
                            </ol>
                          </div>
                          <!--favorite checkbox -->
                          <label class="fav-simple" >
                            <input type="checkbox" style="margin:0; margin-right: 5px;" class="fav-item" data-id="${itemId}" ${favChecked}>
                            <span class="fav-text">Mark as Favorite</span>
                          </label>

                        </div>
                      </div>
                    </div>
                  </div> <!-- /.row -->
                </div> <!-- /.panel-body -->
              </div> <!-- /.panel -->
            `;

            $("#results").append(cardTopContent);
          });

          // Reset the select-all state and text
          allSelected = false;
          $("#selectAllBtn").text("Select All");

          // Update selected count display
          updateSelectedCount();

          // // Add event listener for checkboxes
          $(".select-item").on("change", function () {
            const isChecked = $(this).prop("checked");
            $(this)
              .closest(".selectable-card")
              .toggleClass("selected-card", isChecked);
            updateSelectedCount();
          });
        }

        // Update selected count and show/hide fixed export buttons
        function updateSelectedCount() {
          let totalSelected = $(".select-item:checked").length;
          $("#selectedCount").text(`Selected: ${totalSelected}`);
          $("#fixedSelectedCount").text(`Selected: ${totalSelected}`);

          // Show fixed buttons only if there are selected items
          if (totalSelected > 0) {
            $("#fixedExportButtons").fadeIn();
          } else {
            $("#fixedExportButtons").fadeOut();
          }
        }

        // // toggle when clicking anywhere on the panel body except links/buttons/checkbox
        // $(document).on("click", ".selectable-card .panel-body", function (e) {
        //   // ignore clicks on interactive elements
        //   if ($(e.target).closest("a, button, .select-item, label").length)
        //     return;

        //   const $panel = $(this).closest(".panel");
        //   const $cb = $panel.find(".select-item").first();

        //   $cb.prop("checked", !$cb.prop("checked")).trigger("change");
        // });

        // // keep visual state in sync if user clicks the checkbox directly
        // $(document).on("change", ".select-item", function () {
        //   const $panel = $(this).closest(".panel");
        //   $panel.toggleClass("is-selected", $(this).is(":checked"));
        // });

        // // optional: prevent link/button clicks from bubbling (belt & suspenders)
        // $(document).on(
        //   "click",
        //   ".selectable-card a, .selectable-card button",
        //   function (e) {
        //     e.stopPropagation();
        //   }
        // );

        // Toggle "Select All" functionality
        $("#selectAllBtn").click(function () {
          allSelected = !allSelected;
          $(".select-item").prop("checked", allSelected).change();
          $(".selectable-card").toggleClass("selected-card", allSelected);
          $("#selectAllBtn").text(allSelected ? "Deselect All" : "Select All");

          // Update selected count display
          updateSelectedCount();
        });

        // Export selected items to CSV from top or fixed buttons
        $("#exportTopBtnCsv, #exportFixedBtnCsv").click(function () {
          const selectedItems = getSelectedItems();
          console.log(selectedItems.length);
          console.log(selectedItems);
          if (selectedItems.length === 0) {
            alert("Please select at least one item to export.");
            return;
          }
          exportToCSV(selectedItems);
        });

        // Function to get selected items
        function getSelectedItems() {
          let selectedItems = [];
          $(".select-item:checked").each(function () {
            const index = parseInt($(this).data("index")); // Get the index from data attribute
            if (!isNaN(index)) {
              const match = data.find((item) => item.index === index); // Match by index key
              if (match) {
                selectedItems.push(match);
              }
            }
          });
          console.log(selectedItems);
          return selectedItems;
        }

        // Function to export data to CSV
        // Function to export data to CSV with dynamic filename
        function exportToCSV(data) {
          // Read current filter selections
          const selectedFocusArea = $("#focusArea").val();
          const selectedTC = $("#targetCrash").val();
          const selectedCF = $("#contributingFactors").val();
          const selectedAT = $("#areaType").val();
          const selectedSSA = $("#ssaElements").val();

          const baseUrl = window.location.origin;

          // Helpers
          const isNonEmpty = (v) =>
            v !== undefined &&
            v !== null &&
            String(v).trim() !== "" &&
            String(v).trim().toLowerCase() !== "all";

          const sanitize = (s) =>
            String(s)
              .trim()
              .replace(/[,]/g, "") // remove commas
              .replace(/\s+/g, "-") // spaces -> hyphen
              .replace(/[^a-zA-Z0-9-_]/g, "") // keep filename-safe
              .slice(0, 40); // keep it short

          const pad2 = (n) => (n < 10 ? "0" + n : "" + n);
          const now = new Date();
          const timestamp =
            [
              now.getFullYear(),
              pad2(now.getMonth() + 1),
              pad2(now.getDate()),
            ].join("") +
            "_" +
            [
              pad2(now.getHours()),
              pad2(now.getMinutes()),
              pad2(now.getSeconds()),
            ].join("");

          // Build filename parts only from non-empty filters
          const nameParts = ["countermeasures"];
          if (isNonEmpty(selectedSSA))
            nameParts.push("ssa-" + sanitize(selectedSSA));
          if (isNonEmpty(selectedFocusArea))
            nameParts.push("ea-" + sanitize(selectedFocusArea));
          if (isNonEmpty(selectedTC))
            nameParts.push("tc-" + sanitize(selectedTC));
          if (isNonEmpty(selectedCF)) {
            // use only first factor for brevity
            const cfFirst = String(selectedCF).split(",")[0];
            nameParts.push("cf-" + sanitize(cfFirst));
          }
          if (isNonEmpty(selectedAT))
            nameParts.push("land-" + sanitize(selectedAT));

          const fileName = `${nameParts.join("_")}_${timestamp}.csv`;

          // Build CSV
          const csvRows = [];
          const headers = Object.keys(data[0]).filter(
            (header) =>
              header !== "index" &&
              header !== "id" &&
              header !== "CountermeasureID"
          );
          csvRows.push(headers.join(","));

          data.forEach((item) => {
            const values = headers.map((header) => {
              if (header === "img") {
                return JSON.stringify(
                  `${baseUrl}/core/images/countermeasures/${item[header] || ""}`
                );
              }
              return JSON.stringify(item[header] || "");
            });
            csvRows.push(values.join(","));
          });

          // Download
          const csvContent = csvRows.join("\n");
          const blob = new Blob([csvContent], { type: "text/csv" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // --- Favorites helpers ---
        const FAV_KEY = "cm_favs_v1";
        const getFavs = () => {
          try {
            return JSON.parse(localStorage.getItem(FAV_KEY) || "[]");
          } catch {
            return [];
          }
        };
        const isFav = (id) => getFavs().includes(id);
        const setFav = (id, on) => {
          const s = new Set(getFavs());
          on ? s.add(id) : s.delete(id);
          localStorage.setItem(FAV_KEY, JSON.stringify([...s]));
        };
        const getItemId = (item) => String(item["CountermeasureID"]);

        // Return only favorited items from the FULL data set (ignores current query/filters)
        function getFavoriteItemsFromAll() {
          const favs = new Set(getFavs());
          return data.filter((it) => favs.has(getItemId(it)));
        }

        // Toggle favorite on change (event delegation)
        $("#results").on("change", ".fav-item", function () {
          const id = $(this).data("id");
          setFav(id, this.checked);
        });
        $("#showFavsOnlyBtn").on("click", function () {
          const favList = getFavoriteItemsFromAll(); // from FULL data
          displayResults(favList); // reuse your existing renderer
        });
      });
    </script>
  </body>
</html>
